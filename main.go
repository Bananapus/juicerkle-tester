package main

import (
	"context"
	"encoding/json"
	"io"
	"log"
	"net/http"

	reg "github.com/Bananapus/juicerkle-simulator/BPSuckerRegistry"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
)

/*
1. Read latest sucker registries from GitHub
2. Pay a project on one chain from two different wallets
3. Suck to other chain and claim using the proofs generated by juicerkle.
*/

func main() {
	/*
	 * Step one: Get the latest sucker registries from GitHub
	 */

	deploymentsUrl := "https://raw.githubusercontent.com/Bananapus/nana-suckers/master/deployments/nana-suckers/"
	networks := []struct {
		name     string
		rpcUrl   string
		urlPath  string
		client   *ethclient.Client
		registry *reg.BPSuckerRegistry
	}{
		{name: "Sepolia", rpcUrl: "https://rpc.ankr.com/eth_sepolia", urlPath: "sepolia"},
		{name: "Optimism Sepolia", rpcUrl: "https://rpc.ankr.com/optimism_sepolia", urlPath: "optimism_sepolia"},
	}

	for _, network := range networks {
		// Set up the client for the network
		client, err := ethclient.Dial(network.rpcUrl)
		if err != nil {
			log.Fatalf("Error dialing %s: %s\n", network.rpcUrl, err)
		}
		network.client = client

		// Get the sucker registry on that chain
		registryUrl := deploymentsUrl + network.urlPath + "/BPSuckerRegistry.json"
		resp, err := http.Get(registryUrl)
		if err != nil {
			log.Fatalf("Error fetching %s: %s\n", registryUrl, err)
		}

		defer resp.Body.Close()
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			log.Fatal(err)
		}

		var deployedTo struct {
			Address string `json:"address"`
		}
		if err = json.Unmarshal(body, &deployedTo); err != nil {
			log.Fatalf("Error unmarshalling %s: %s\n", registryUrl, err)
		}
		if deployedTo.Address == "" {
			log.Fatalf("Could not find sucker registry address on: %s\n", registryUrl)
		}

		registry, err := reg.NewBPSuckerRegistry(common.HexToAddress(deployedTo.Address), network.client)
		if err != nil {
			log.Fatalf("Error initializing sucker registry on %s: %s\n", network.name, err)
		}

		network.registry = registry

		projects, err := registry.PROJECTS(&bind.CallOpts{Context: context.TODO()})
		if err != nil {
			log.Fatalf("Error fetching PROJECTS() from %s on %s: %s\n", deployedTo.Address, network.name, err)
		}

		log.Printf("PROJECTS() from %s on %s: %s\n", deployedTo.Address, network.name, projects)
	}

}
