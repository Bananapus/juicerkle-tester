package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"math/big"
	"net/http"
	"os"
	"sync"

	reg "github.com/Bananapus/juicerkle-tester/bindings/BPSuckerRegistry"
	con "github.com/Bananapus/juicerkle-tester/bindings/JBController"

	"github.com/ethereum/go-ethereum/accounts"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
)

/*
Set up a keystore with:
mkdir keystore
cast wallet new -p keystore

Fund the wallet on the networks you want to test.

Run this with -p to unlock the wallet.

1. Read latest sucker registries from GitHub
2. Pay a project on one chain from two different wallets
3. Suck to other chain and claim using the proofs generated by juicerkle.
*/

const (
	suckerDeployUrl       = "https://raw.githubusercontent.com/Bananapus/nana-suckers/master/deployments/nana-suckers/"
	coreDeployUrl         = "https://raw.githubusercontent.com/Bananapus/nana-core/main/deployments/nana-core/"
	sepoliaRpcUrl         = "https://rpc.ankr.com/eth_sepolia"
	optimismSepoliaRpcUrl = "https://rpc.ankr.com/optimism_sepolia"
)

type NetworkConfig struct {
	chainId *big.Int
	rpcUrl  string
}

var networkConfigs = map[string]NetworkConfig{
	"sepolia":          {big.NewInt(1), sepoliaRpcUrl},
	"optimism_sepolia": {big.NewInt(10), optimismSepoliaRpcUrl},
}

type SaveFileNetwork struct {
	ProjectId       string   `json:"projectId"`
	SuckerAddresses []string `json:"suckerAddress"`
	ProjectOwner    string   `json:"projectOwner"`
}

func main() {
	keystoreDir := flag.String("dir", "keystore", "The directory where your keystore is located.")
	keystorePassword := flag.String("pass", "", "The password to unlock your keystore.")
	keystoreIndex := flag.Int("index", 0, "The index of the account in the keystore to use.")
	savePath := flag.String("save", "save.json", "The save.json filepath from which to read and/or store project and sucker data.")
	noSave := flag.Bool("nosave", false, "Do not save updated project and sucker data to the save file.")
	flag.Parse()

	// Read the save file
	save := struct {
		sync.RWMutex
		Data map[string]SaveFileNetwork
	}{
		Data: make(map[string]SaveFileNetwork),
	}

	if _, err := os.Stat(*savePath); err == nil {
		saveFile, err := os.Open(*savePath)
		if err != nil {
			log.Fatalf("Error opening save file '%s': %s\n", *savePath, err)
		}
		decoder := json.NewDecoder(saveFile)
		if err := decoder.Decode(&save.Data); err != nil {
			log.Fatalf("Error decoding save file '%s': %s\n", *savePath, err)
		}
		saveFile.Close()
	} else if !os.IsNotExist(err) {
		log.Fatalf("Error checking save file '%s': %s\n", *savePath, err)
	}

	// Write updated data to the save file on exit
	defer func() {
		if !*noSave {
			saveFile, err := os.Create(*savePath) // Overwrite
			if err != nil {
				log.Fatalf("Error creating save file at %s: %s\n", *savePath, err)
			}
			defer saveFile.Close()

			if err := json.NewEncoder(saveFile).Encode(save.Data); err != nil {
				log.Fatalf("Error writing to save file at %s: %s\n", *savePath, err)
			}
		}
	}()

	// Set up the wallet from the keystore
	if _, err := os.Stat(*keystoreDir); os.IsNotExist(err) {
		if err := os.Mkdir(*keystoreDir, 0o700); err != nil {
			log.Fatalf("Error creating keystore directory: %s\n", err)
		}
	} else if err != nil {
		log.Fatalf("Error checking keystore directory: %s\n", err)
	}
	ks := keystore.NewKeyStore(*keystoreDir, keystore.StandardScryptN, keystore.StandardScryptP)

	if len(ks.Accounts()) == 0 {
		fmt.Println("No accounts found in keystore. Creating one...")
		keystoreAccount, err := ks.NewAccount(*keystorePassword)
		if err != nil {
			log.Fatalf("Error creating keystore account: %s\n", err)
		}
		fmt.Printf("Created keystore account: %s\nFund this wallet and re-run without -init", keystoreAccount.Address.Hex())
		os.Exit(0)
	} else {
		if *keystoreIndex >= len(ks.Accounts()) {
			log.Fatalf("Keystore index %d is out of range. Keystore %s only has %d accounts.\n", *keystoreIndex, *keystoreDir, len(ks.Accounts()))
		}
		if err := ks.Unlock(ks.Accounts()[*keystoreIndex], *keystorePassword); err != nil {
			log.Fatalf("Error unlocking keystore: %s\n", err)
		}
		defer ks.Lock(ks.Accounts()[*keystoreIndex].Address)
		fmt.Printf("Found keystore account: %s\n", ks.Accounts()[0].Address.Hex())
	}

	userAddr := ks.Accounts()[*keystoreIndex].Address

	// Set up the clients and contracts on each network
	sepolia, err := setupNetwork("sepolia", ks, ks.Accounts()[*keystoreIndex])
	if err != nil {
		log.Fatalf("Setup error on Sepolia: %s\n", err)
	}

	optimismSepolia, err := setupNetwork("optimism_sepolia", ks, ks.Accounts()[*keystoreIndex])
	if err != nil {
		log.Fatalf("Setup error on Optimism Sepolia: %s\n", err)
	}

	// Launch projects and suckers on each chain.
	var wg sync.WaitGroup
	ctx, cancel := context.WithCancel(context.Background())
	for _, network := range []SetupNetwork{sepolia, optimismSepolia} {
		wg.Add(1)
		go func() {
			defer wg.Done()
			save.RLock()
			networkSave, _ := save.Data[network.name]
			save.RUnlock()

			// Skip if we already have sucker addresses (meaning we already have a project)
			if len(networkSave.SuckerAddresses) != 0 {
				return
			}

			// Write any updated data to the save file
			defer func() {
				save.Lock()
				save.Data[network.name] = networkSave
				save.Unlock()
			}()

			// Launch a project if we don't have one
			if networkSave.ProjectId == "" {
				log.Printf("Launching a new project on %s\n", network.name)

				// TODO: Tx logic is duplicative. Could this be refactored?
				tx, err := network.controller.LaunchProjectFor(
					network.transactor,
					userAddr,
					"",
					[]con.JBRulesetConfig{},
					[]con.JBTerminalConfig{},
					"Excellent success.",
				)

				if err != nil {
					cancel()
					log.Fatalf("Error launching project on %s: %s\n", network.client, err)
				}

				log.Printf("Launching project on %s in tx %s ...\n", network.name, tx.Hash().Hex())
				receipt, err := bind.WaitMined(ctx, network.client, tx)
				if err != nil {
					cancel()
					log.Fatalf("Error waiting for project launch on %s: %s\n", network.name, err)
				}

				foundLaunchLog := false
				for _, vLog := range receipt.Logs {
					launchLog, err := network.controller.ParseLaunchProject(*vLog)
					if err != nil {
						continue
					}
					foundLaunchLog = true
					networkSave.ProjectId = launchLog.ProjectId.String() // Add to save data
					log.Printf("Launched project #%s on %s\n", launchLog.ProjectId, network.name)
					break
				}

				if !foundLaunchLog {
					log.Fatalf("Could not find a LaunchProject event for transaction %s on %s", tx.Hash().Hex(), network.name)
				}
			}

			projectId, success := new(big.Int).SetString(networkSave.ProjectId, 10)
			if !success {
				log.Fatalf("Error parsing project ID from save file: '%s'\n", networkSave.ProjectId)
			}

			// We know there's no sucker (we checked above)
			log.Printf("Launching a sucker for project %s on %s\n", networkSave.ProjectId, network.name)
			tx, err := network.registry.DeploySuckersFor(
				network.transactor,
				projectId,
				[32]byte{},
				[]reg.BPSuckerDeployerConfig{},
			)
			if err != nil {
				cancel()
				log.Fatalf("Error deploying sucker for project %s on %s: %s\n", networkSave.ProjectId, network.name, err)
			}

			log.Printf("Deploying sucker for project %s on %s in tx %s ...\n", networkSave.ProjectId, network.name, tx.Hash().Hex())
			receipt, err := bind.WaitMined(ctx, network.client, tx)
			if err != nil {
				cancel()
				log.Fatalf("Error waiting for sucker deployment for project %s on %s: %s\n", networkSave.ProjectId, network.name, err)
			}

			foundDeployLog := false
			for _, vLog := range receipt.Logs {
				deployLog, err := network.registry.ParseSuckersDeployedFor(*vLog)
				if err != nil {
					continue
				}
				foundDeployLog = true

				// Convert sucker addresses to strings and add to save data.
				suckerStrs := make([]string, len(deployLog.Suckers))
				for i, sucker := range deployLog.Suckers {
					suckerStrs[i] = sucker.String()
				}
				networkSave.SuckerAddresses = suckerStrs
				log.Printf("Launched suckers for project #%s on %s: %v\n", projectId, network.name, suckerStrs)
				break
			}

			if !foundDeployLog {
				log.Fatalf("Could not find a SuckersDeployed event for transaction %s on %s", tx.Hash().Hex(), network.name)
			}
		}()
	}

	wg.Wait()

}

type SetupNetwork struct {
	name       string
	client     *ethclient.Client
	transactor *bind.TransactOpts
	registry   *reg.BPSuckerRegistry
	controller *con.JBController
}

func setupNetwork(networkConfig string, ks *keystore.KeyStore, act accounts.Account) (SetupNetwork, error) {
	n, ok := networkConfigs[networkConfig]
	if !ok {
		return SetupNetwork{}, fmt.Errorf("Network %s not found in networks.\n", networkConfig)
	}

	// Set up the client for the network
	client, err := ethclient.Dial(n.rpcUrl)
	if err != nil {
		return SetupNetwork{}, fmt.Errorf("Error dialing %s: %s\n", n.rpcUrl, err)
	}

	// Set up the transactor for the network
	auth, err := bind.NewKeyStoreTransactorWithChainID(ks, act, n.chainId)
	if err != nil {
		return SetupNetwork{}, fmt.Errorf("Error setting up transactor on %s: %s\n", networkConfig, err)
	}

	// Get the controller on that chain
	controllerUrl := coreDeployUrl + networkConfig + "/JBController.json"
	controllerAddress, err := deployedTo(controllerUrl)
	if err != nil {
		return SetupNetwork{}, fmt.Errorf("Error getting JBController address on %s: %s\n", networkConfig, err)
	}
	controller, err := con.NewJBController(controllerAddress, client)
	if err != nil {
		return SetupNetwork{}, fmt.Errorf("Error initializing JBController on %s: %s\n", networkConfig, err)
	}

	// Get the sucker registry on that chain
	registryUrl := suckerDeployUrl + networkConfig + "/BPSuckerRegistry.json"
	registryAddress, err := deployedTo(registryUrl)
	if err != nil {
		return SetupNetwork{}, fmt.Errorf("Error getting BPSuckerRegistry address on %s: %s\n", networkConfig, err)
	}
	registry, err := reg.NewBPSuckerRegistry(registryAddress, client)
	if err != nil {
		return SetupNetwork{}, fmt.Errorf("Error initializing BPSuckerRegistry on %s: %s\n", networkConfig, err)
	}

	name := networkConfig
	return SetupNetwork{name, client, auth, registry, controller}, nil
}

func deployedTo(jsonUrl string) (common.Address, error) {
	resp, err := http.Get(jsonUrl)
	if err != nil {
		log.Fatalf("Error fetching %s: %s\n", jsonUrl, err)
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return common.Address{}, err
	}

	var deployedTo struct {
		Address string `json:"address"`
	}
	if err = json.Unmarshal(body, &deployedTo); err != nil {
		return common.Address{}, fmt.Errorf("Error unmarshalling %s: %s\n", jsonUrl, err)
	}
	if deployedTo.Address == "" {
		return common.Address{}, fmt.Errorf("Could not find deployment address from: %s\n", jsonUrl)
	}

	return common.HexToAddress(deployedTo.Address), nil
}
