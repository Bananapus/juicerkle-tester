package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"math/big"
	"net/http"
	"os"
	"sync"

	suck "github.com/Bananapus/juicerkle-tester/bindings/BPSucker"
	reg "github.com/Bananapus/juicerkle-tester/bindings/BPSuckerRegistry"
	con "github.com/Bananapus/juicerkle-tester/bindings/JBController"
	term "github.com/Bananapus/juicerkle-tester/bindings/JBMultiTerminal"

	"github.com/ethereum/go-ethereum/accounts"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/accounts/keystore"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
)

/*
Set up a keystore with:
mkdir keystore
cast wallet new -p keystore

Fund the wallet on the networks you want to test.

Run this with -p to unlock the wallet.

1. Read latest sucker registries from GitHub
2. Pay a project on one chain from two different wallets
3. Suck to other chain and claim using the proofs generated by juicerkle.
*/

const (
	suckerDeployUrl       = "https://raw.githubusercontent.com/Bananapus/nana-suckers/master/deployments/nana-suckers/"
	coreDeployUrl         = "https://raw.githubusercontent.com/Bananapus/nana-core/main/deployments/nana-core/"
	sepoliaRpcUrl         = "https://rpc.ankr.com/eth_sepolia"
	optimismSepoliaRpcUrl = "https://rpc.ankr.com/optimism_sepolia"
)

var (
	nativeTokenAddress = common.HexToAddress("0x000000000000000000000000000000000000EEEe")
)

type NetworkConfig struct {
	chainId *big.Int
	rpcUrl  string
}

var networkConfigs = map[string]NetworkConfig{
	"sepolia":          {big.NewInt(11155111), sepoliaRpcUrl},
	"optimism_sepolia": {big.NewInt(11155420), optimismSepoliaRpcUrl},
}

type SaveFileNetwork struct {
	ProjectId       string   `json:"projectId"`
	SuckerAddresses []string `json:"suckerAddress"`
}

func main() {
	keystoreDir := flag.String("dir", "keystore", "The directory where your keystore is located.")
	keystorePassword := flag.String("pass", "", "The password to unlock your keystore.")
	keystoreIndex := flag.Int("index", 0, "The index of the account in the keystore to use.")
	savePath := flag.String("save", "save.json", "The save.json filepath from which to read and/or store project and sucker data.")
	noSave := flag.Bool("nosave", false, "Do not save updated project and sucker data to the save file.")
	flag.Parse()

	// Read the save file
	save := struct {
		sync.RWMutex
		Data map[string]SaveFileNetwork
	}{
		Data: make(map[string]SaveFileNetwork),
	}

	if _, err := os.Stat(*savePath); err == nil {
		saveFile, err := os.Open(*savePath)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error opening save file '%s': %s\n", *savePath, err)
			return
		}
		decoder := json.NewDecoder(saveFile)
		if err := decoder.Decode(&save.Data); err != nil {
			fmt.Fprintf(os.Stderr, "Error decoding save file '%s': %s\n", *savePath, err)
			return
		}
		saveFile.Close()
	} else if !os.IsNotExist(err) {
		fmt.Fprintf(os.Stderr, "Error checking save file '%s': %s\n", *savePath, err)
		return
	}

	// Write updated data to the save file on exit
	defer func() {
		if !*noSave {
			saveFile, err := os.Create(*savePath) // Overwrite
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error creating save file at %s: %s\n", *savePath, err)
				return
			}
			defer saveFile.Close()

			if err := json.NewEncoder(saveFile).Encode(save.Data); err != nil {
				fmt.Fprintf(os.Stderr, "Error writing to save file at %s: %s\n", *savePath, err)
			}
		}
	}()

	// Set up the wallet from the keystore
	if _, err := os.Stat(*keystoreDir); os.IsNotExist(err) {
		if err := os.Mkdir(*keystoreDir, 0o700); err != nil {
			fmt.Fprintf(os.Stderr, "Error creating keystore directory: %s\n", err)
			return
		}
	} else if err != nil {
		fmt.Fprintf(os.Stderr, "Error checking keystore directory: %s\n", err)
		return
	}
	ks := keystore.NewKeyStore(*keystoreDir, keystore.StandardScryptN, keystore.StandardScryptP)

	if len(ks.Accounts()) == 0 {
		fmt.Println("No accounts found in keystore. Creating one...")
		keystoreAccount, err := ks.NewAccount(*keystorePassword)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error creating keystore account: %s\n", err)
			return
		}
		fmt.Printf("Created keystore account: %s\nFund the wallet and re-run this program.\n", keystoreAccount.Address.Hex())
		os.Exit(0)
	} else {
		if *keystoreIndex >= len(ks.Accounts()) {
			fmt.Fprintf(os.Stderr, "Keystore index %d is out of range. Keystore %s only has %d accounts.\n", *keystoreIndex, *keystoreDir, len(ks.Accounts()))
			return
		}
		if err := ks.Unlock(ks.Accounts()[*keystoreIndex], *keystorePassword); err != nil {
			fmt.Fprintf(os.Stderr, "Error unlocking keystore: %s\n", err)
			return
		}
		defer ks.Lock(ks.Accounts()[*keystoreIndex].Address)
		fmt.Printf("Found keystore account: %s\n", ks.Accounts()[0].Address.Hex())
	}

	userAddr := ks.Accounts()[*keystoreIndex].Address

	// Set up the clients and contracts on each network
	sepolia, err := setupNetwork("sepolia", ks, ks.Accounts()[*keystoreIndex])
	if err != nil {
		fmt.Fprintf(os.Stderr, "Setup error on Sepolia: %s\n", err)
		return
	}

	optimismSepolia, err := setupNetwork("optimism_sepolia", ks, ks.Accounts()[*keystoreIndex])
	if err != nil {
		fmt.Fprintf(os.Stderr, "Setup error on Optimism Sepolia: %s\n", err)
		return
	}

	// Launch projects and suckers on each chain.
	networks := []SetupNetwork{sepolia, optimismSepolia}
	var wg sync.WaitGroup
	errsCh := make(chan error, len(networks))

	ctx, cancel := context.WithCancel(context.Background())
	for _, network := range networks {
		wg.Add(1)
		go func() {
			defer wg.Done()
			save.RLock()
			networkSave, _ := save.Data[network.name]
			save.RUnlock()

			// Skip if we already have sucker addresses (meaning we already have a project)
			if len(networkSave.SuckerAddresses) != 0 {
				return
			}

			// Write any updated data to the save file
			defer func() {
				save.Lock()
				save.Data[network.name] = networkSave
				save.Unlock()
			}()

			// Launch a project if we don't have one
			if networkSave.ProjectId == "" {
				fmt.Printf("Launching a new project on %s\n", network.name)

				// TODO: Tx logic is duplicative. Could this be refactored?
				tx, err := network.controller.LaunchProjectFor(
					network.transactor,
					userAddr,
					"",
					[]con.JBRulesetConfig{{Weight: big.NewInt(1e18)}}, // Everything else is zero-valued
					[]con.JBTerminalConfig{{
						Terminal:       network.terminalAddress,
						TokensToAccept: []common.Address{nativeTokenAddress},
					}},
					"Launched with juicerkle-tester.",
				)

				if err != nil {
					cancel()
					errsCh <- fmt.Errorf("Error launching project on %s: %s\n", network.name, err)
					return
				}

				fmt.Printf("Launching project on %s in tx %s ...\n", network.name, tx.Hash())
				receipt, err := bind.WaitMined(ctx, network.client, tx)
				if err != nil {
					cancel()
					errsCh <- fmt.Errorf("Error waiting for project launch on %s: %s\n", network.name, err)
					return
				}

				foundLaunchLog := false
				for _, vLog := range receipt.Logs {
					launchLog, err := network.controller.ParseLaunchProject(*vLog)
					if err != nil {
						continue
					}
					foundLaunchLog = true
					networkSave.ProjectId = launchLog.ProjectId.String() // Add to save data
					fmt.Printf("Launched project #%s on %s\n", launchLog.ProjectId, network.name)
					break
				}
				if !foundLaunchLog {
					cancel()
					errsCh <- fmt.Errorf("Could not find a LaunchProject event for transaction %s on %s", tx.Hash(), network.name)
					return
				}
			}

			projectId, success := new(big.Int).SetString(networkSave.ProjectId, 10)
			if !success {
				cancel()
				errsCh <- fmt.Errorf("Error parsing project ID from save file: '%s'\n", networkSave.ProjectId)
				return
			}

			// We know there's no sucker (we checked above)
			fmt.Printf("Launching a sucker for project %s on %s\n", networkSave.ProjectId, network.name)
			tx, err := network.registry.DeploySuckersFor(
				network.transactor,
				projectId,
				[32]byte{},
				[]reg.BPSuckerDeployerConfig{{
					Deployer: network.suckerDeployer,
					Mappings: []reg.BPTokenMapping{{
						LocalToken:  nativeTokenAddress,
						RemoteToken: nativeTokenAddress,
					}},
				}},
			)
			if err != nil {
				cancel()
				errsCh <- fmt.Errorf("Error deploying sucker for project %s on %s: %s\n", networkSave.ProjectId, network.name, err)
				return
			}

			fmt.Printf("Deploying sucker for project %s on %s in tx %s ...\n", networkSave.ProjectId, network.name, tx.Hash())
			receipt, err := bind.WaitMined(ctx, network.client, tx)
			if err != nil {
				cancel()
				errsCh <- fmt.Errorf("Error waiting for sucker deployment for project %s on %s: %s\n", networkSave.ProjectId, network.name, err)
				return
			}

			foundDeployLog := false
			for _, vLog := range receipt.Logs {
				deployLog, err := network.registry.ParseSuckersDeployedFor(*vLog)
				if err != nil {
					continue
				}
				foundDeployLog = true

        if len(deployLog.Suckers) == 0 {
          cancel()
          errsCh <- fmt.Errorf("No suckers deployed for project #%s on %s", projectId, network.name)
          return
        }

				// Convert sucker addresses to strings and add to save data.
				suckerStrs := make([]string, len(deployLog.Suckers))
				for i, sucker := range deployLog.Suckers {
					suckerStrs[i] = sucker.String()
				}
				networkSave.SuckerAddresses = suckerStrs
				fmt.Printf("Launched suckers for project #%s on %s: %v\n", projectId, network.name, suckerStrs)

        // Set up sucker binding
        sucker, err := suck.NewBPSucker(deployLog.Suckers[0], network.client)
        if err != nil {
          cancel()
          errsCh <- fmt.Errorf("Error initializing sucker on %s: %s\n", network.name, err)
          return
        }
        network.sucker = sucker

				break
			}

			if !foundDeployLog {
				cancel()
				errsCh <- fmt.Errorf("Could not find a SuckersDeployed event for transaction %s on %s", tx.Hash(), network.name)
				return
			}

		}()
	}

	wg.Wait()
	close(errsCh)
	for err := range errsCh {
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			return
		}
	}

	// Part 2: Pay the project on both chains and attend to bridge with the suckers.
	errsCh = make(chan error, len(networks))
	for _, network := range networks {
		wg.Add(1)
		go func() {
			defer wg.Done()
			save.RLock()
			networkSave, _ := save.Data[network.name]
			save.RUnlock()

      // Make sure we have a sucker
      if network.sucker == nil {
        cancel()
        errsCh <- fmt.Errorf("No sucker saved for project #%s on %s", networkSave.ProjectId, network.name)
        return
      }

			projectId, success := new(big.Int).SetString(networkSave.ProjectId, 10)
			if !success {
				cancel()
				errsCh <- fmt.Errorf("Error parsing project ID from save file: '%s'\n", networkSave.ProjectId)
				return
			}

			// Pay the project
			tx, err := network.terminal.Pay(
				network.transactor,
				projectId,
				nativeTokenAddress,
				big.NewInt(100), // 100 wei
				userAddr,
				big.NewInt(0),
				"Paid from juicerkle-tester",
				[]byte{},
			)
			if err != nil {
				cancel()
				fmt.Fprintf(os.Stderr, "Error paying project %s on %s: %s\n", networkSave.ProjectId, network.name, err)
				return
			}

			receipt, err := bind.WaitMined(ctx, network.client, tx)
			if err != nil {
				cancel()
				fmt.Fprintf(os.Stderr, "Error waiting for project payment on %s: %s\n", network.name, err)
				return
			}

			foundPayLog := false
			for _, vLog := range receipt.Logs {
				payLog, err := network.terminal.ParsePay(*vLog)
				if err != nil {
					continue
				}
				foundPayLog = true
				fmt.Printf("Successfully paid project %s in transaction %s on %s.\n", payLog.ProjectId, tx.Hash(), network.name)
				break
			}
			if !foundPayLog {
				cancel()
				errsCh <- fmt.Errorf("Could not find a Pay event for transaction %s on %s", tx.Hash(), network.name)
				return
			}

		}()
	}

	wg.Wait()
	close(errsCh)
	for err := range errsCh {
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			return
		}
	}

}

type SetupNetwork struct {
	name            string
	client          *ethclient.Client
	transactor      *bind.TransactOpts
	sucker          *suck.BPSucker
	registry        *reg.BPSuckerRegistry
	controller      *con.JBController
	terminal        *term.JBMultiTerminal
	terminalAddress common.Address
	suckerDeployer  common.Address
}

func setupNetwork(networkConfig string, ks *keystore.KeyStore, act accounts.Account) (SetupNetwork, error) {
	n, ok := networkConfigs[networkConfig]
	if !ok {
		return SetupNetwork{}, fmt.Errorf("Network %s not found in networks.\n", networkConfig)
	}

	// Set up the client for the network
	client, err := ethclient.Dial(n.rpcUrl)
	if err != nil {
		return SetupNetwork{}, fmt.Errorf("Error dialing %s: %s\n", n.rpcUrl, err)
	}

	// Set up the transactor for the network
	auth, err := bind.NewKeyStoreTransactorWithChainID(ks, act, n.chainId)
	if err != nil {
		return SetupNetwork{}, fmt.Errorf("Error setting up transactor on %s: %s\n", networkConfig, err)
	}

	// Get the controller on that chain
	controllerUrl := coreDeployUrl + networkConfig + "/JBController.json"
	controllerAddress, err := deployedTo(controllerUrl)
	if err != nil {
		return SetupNetwork{}, fmt.Errorf("Error getting JBController address on %s: %s\n", networkConfig, err)
	}
	controller, err := con.NewJBController(controllerAddress, client)
	if err != nil {
		return SetupNetwork{}, fmt.Errorf("Error initializing JBController on %s: %s\n", networkConfig, err)
	}

	// Get the multi terminal on that chain
	multiTerminalUrl := coreDeployUrl + networkConfig + "/JBMultiTerminal.json"
	terminalAddress, err := deployedTo(multiTerminalUrl)
	if err != nil {
		return SetupNetwork{}, fmt.Errorf("Error getting JBMultiTerminal address on %s: %s\n", networkConfig, err)
	}
	terminal, err := term.NewJBMultiTerminal(terminalAddress, client)
	if err != nil {
		return SetupNetwork{}, fmt.Errorf("Error initializing JBMultiTerminal on %s: %s\n", networkConfig, err)
	}

	suckerDeployerUrl := coreDeployUrl + networkConfig + "/BPOptimismSuckerDeployer.json"
	suckerDeployerAddress, err := deployedTo(suckerDeployerUrl)
	if err != nil {
		return SetupNetwork{}, fmt.Errorf("Error getting BPOptimismSuckerDeployer address on %s: %s\n", networkConfig, err)
	}

	// Get the sucker registry on that chain
	registryUrl := suckerDeployUrl + networkConfig + "/BPSuckerRegistry.json"
	registryAddress, err := deployedTo(registryUrl)
	if err != nil {
		return SetupNetwork{}, fmt.Errorf("Error getting BPSuckerRegistry address on %s: %s\n", networkConfig, err)
	}
	registry, err := reg.NewBPSuckerRegistry(registryAddress, client)
	if err != nil {
		return SetupNetwork{}, fmt.Errorf("Error initializing BPSuckerRegistry on %s: %s\n", networkConfig, err)
	}

	name := networkConfig
	return SetupNetwork{name, client, auth, nil, registry, controller, terminal, terminalAddress, suckerDeployerAddress}, nil
}

func deployedTo(jsonUrl string) (common.Address, error) {
	resp, err := http.Get(jsonUrl)
	if err != nil {
		return common.Address{}, fmt.Errorf("Error fetching %s: %s\n", jsonUrl, err)
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return common.Address{}, err
	}

	var deployedTo struct {
		Address string `json:"address"`
	}
	if err = json.Unmarshal(body, &deployedTo); err != nil {
		return common.Address{}, fmt.Errorf("Error unmarshalling %s: %s\n", jsonUrl, err)
	}
	if deployedTo.Address == "" {
		return common.Address{}, fmt.Errorf("Could not find deployment address from: %s\n", jsonUrl)
	}

	return common.HexToAddress(deployedTo.Address), nil
}
